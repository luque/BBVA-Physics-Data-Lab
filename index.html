<!DOCTYPE html>
<html lang="en">
<head>
<title>PhyoDAT with BBVA Data API</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=11" />
<link rel="stylesheet" href="css/lab.css"/>
<script src="js/three.min.js"></script>
<script src="js/navigation.js"></script>
<script src="js/Oimo.rev.js"></script>
<script src="js/dataset/monterrey_tech.js"></script>
</head>
<body>
    <h1>PhyoDAT - Physics-oriented Data Analysis Tool</h1>
    <h2>with BBVA Data API</h2>

    <div id="controls">
      
      <div id="months">
        <p>Choose a month:</p>
        <input type="button" value="Nov 2013" onClick="populateWorld(0)">
        <input type="button" value="Dec 2013" onClick="populateWorld(1)">
        <input type="button" value="Jan 2014" onClick="populateWorld(2)">
        <input type="button" value="Feb 2014" onClick="populateWorld(3)">
        <input type="button" value="Mar 2014" onClick="populateWorld(4)">
        <input type="button" value="Apr 2014" onClick="populateWorld(5)">
      </div>     
            
    </div>

    <div id="tools">
      <input id="inspectorBtn" type="button" value="Object Inspector" onClick="toggleInspector()"/>
      <div id="sphereInfo"></div>
    </div>
    
    <div id='lab'></div>

    <div id="dayInfo"></div>
    
<script>
    // Three.js vars
    var camera, scene, light, renderer, container, projector, mouseVector, spheres;
    var selectedMesh, previousSelectedMeshMaterial;
    var meshs = [];
    var bodys=[];
    var grounds = [];
    var isMobile = false;
    var antialias = true;

    var geos = {};
    var mats = {};

    // Oimo vars
    var world = null;
    var bodys = [];
    var updatePhysicsInterval;

    var fps = [0,0,0,0];
    var ToRad = Math.PI / 180;
    var type=1;
    var debugColor = 0x282929;
    var debugColor2 = 0x288829;
    var debugAlpha = 0.3;

    // The Bit of a collision group
    var group1 = 1 << 0;  // 00000000 00000000 00000000 00000001
    var group2 = 1 << 1;  // 00000000 00000000 00000000 00000010
    var group3 = 1 << 2;  // 00000000 00000000 00000000 00000100
    var all = 0xffffffff; // 11111111 11111111 11111111 11111111

    // Is all the physics setting for rigidbody
    var config = [
        1, // The density of the shape.
        0.5, // The coefficient of friction of the shape.
        0.5, // The coefficient of restitution of the shape.
        1, // The bits of the collision groups to which the shape belongs.
        0xffffffff // The bits of the collision groups with which the shape collides.
    ];

    // Dataset vars
    var textureColors = {
        'sph.mx_barsandrestaurants': '#81c16a',
        'sph.mx_services': '#67b0b6',
        'sph.mx_food': '#d66f6c',
        'sph.mx_office': '#c0a0e0',
        'sph.mx_car': '#fa842c',
        'sph.mx_auto':'#fb2d22',
        'sph.mx_travel': '#ebef4e',
        'sph.mx_sport': '#2c66a4',
        'sph.mx_beauty': '#ecc82c',
        'sph.mx_health':'#fffeef'
    };

    var paymentsPerSphere = 50;
    var paymentBucket = 500;
    var radioPerPaymentBucket = 20;

    var yGapBetweenDays = 100;
    var daysOfMonth = [
        30, // 0 -> 11/2013
        31, // 1 -> 12/2013
        31, // 2 -> 01/2014
        28, // 3 -> 02/2014
        31, // 4 -> 03/2014
        30  // 5 -> 04/2014
    ];
    var currentDate = 0;
    var inspectorActivated = false;


    init();
    loop();

    function init() {
        var n = navigator.userAgent;
        if (n.match(/Android/i) ||
            n.match(/webOS/i) ||
            n.match(/iPhone/i) ||
            n.match(/iPad/i) ||
            n.match(/iPod/i) ||
            n.match(/BlackBerry/i) ||
            n.match(/Windows Phone/i)) {
            isMobile = true;
            antialias = false;
        }

        // camera
        var cameraFOV = 60;
        var cameraAspectRatio = window.innerWidth / window.innerHeight;
        var cameraNearPlane = 1;
        var cameraFarPlane = 15000;
        camera = new THREE.PerspectiveCamera(cameraFOV, cameraAspectRatio, cameraNearPlane, cameraFarPlane);
        initCamera(0, 0, 1500);
        camera.lookAt( new THREE.Vector3( 0, 0, 0 ) )        

        scene = new THREE.Scene();

        spheres = new THREE.Object3D();
        scene.add(spheres);        
       
	// object picking stuff
	projector = new THREE.Projector();
	raycaster = new THREE.Raycaster();
        
        // renderer
        renderer = new THREE.WebGLRenderer({precision: "mediump", antialias: antialias});
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;

        // lights
        if (!isMobile){
            var ambientLight = new THREE.AmbientLight(0x555557);
            light = new THREE.DirectionalLight(0xffffff , 1.3);
            light.position.set( 300, 1000, 500 );
            light.target.position.set( 0, 0, 0 );
            light.castShadow = true;
            light.shadowCameraNear = 500;
            light.shadowCameraFar = 1600;
            light.shadowCameraFov = 70;
            light.shadowBias = 0.0001;
            light.shadowDarkness = 0.7;
            //light.shadowCameraVisible = true;
            light.shadowMapWidth = light.shadowMapHeight = 1024;

            scene.add(ambientLight);
            scene.add( light );
            
            renderer.shadowMapEnabled = true;
            renderer.shadowMapType = THREE.PCFShadowMap;
        }

        // background
        var buffgeoBack = new THREE.BufferGeometry();
        buffgeoBack.fromGeometry( new THREE.IcosahedronGeometry(3000,1));
        var back = new THREE.Mesh(buffgeoBack,
            new THREE.MeshBasicMaterial( {
                map: gradTexture([[0.75,0.6,0.4,0.25], ['#1B1D1E','#3D4143','#72797D', '#b0babf']]),
                side: THREE.BackSide,
                depthWrite: false,
                fog: false }  ));
        back.geometry.applyMatrix(new THREE.Matrix4().makeRotationZ(15*ToRad));
        scene.add(back);

        // geometries
        geos['sphere'] = new THREE.BufferGeometry();
        geos['sphere'].fromGeometry( new THREE.SphereGeometry(1,16,10));
        geos['box'] = new THREE.BufferGeometry();
        geos['box'].fromGeometry( new THREE.BoxGeometry(1,1,1));
        geos['cyl'] = new THREE.BufferGeometry();
        geos['cyl'].fromGeometry( new THREE.CylinderGeometry(1, 1, 1, 20));
               
        // materials
        if(!isMobile){
            mats['sph.mx_barsandrestaurants'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_barsandrestaurants'), name:'sph.mx_barsandrestaurants' } );
            mats['sph.mx_services'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_services'), name:'sph.mx_services' } );
            mats['sph.mx_food'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_food'), name:'sph.mx_food' } );            
	    mats['sph.mx_office'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_office'), name:'sph.mx_office' } );            
            mats['sph.mx_car'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_car'), name:'sph.mx_car' } );            
	    mats['sph.mx_auto'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_auto'), name:'sph.mx_auto' } );            
	    mats['sph.mx_travel'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_travel'), name:'sph.mx_travel' } );            
	    mats['sph.mx_sport'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_sport'), name:'sph.mx_sport' } );            
	    mats['sph.mx_beauty'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_beauty'), name:'sph.mx_beauty' } );            
	    mats['sph.mx_health'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_health'), name:'sph.mx_health' } );            


            mats['box'] = new THREE.MeshPhongMaterial( { map: basicTexture(1), name:'box' } );
            mats['filter'] = new THREE.MeshLambertMaterial( { color: 0x3D4143, transparent:true, opacity:0.6 } );            
            mats['ground'] = new THREE.MeshBasicMaterial( { color:debugColor, wireframe:true, transparent:true, opacity:0, fog: false, depthTest: false, depthWrite: false});
        } else {
            mats['sph.mx_barsandrestaurants'] = new THREE.MeshBasicMaterial( { map: basicTexture('sph.mx_barsandrestaurants'), name:'sph.mx_barsandrestaurants' } );
            mats['sph.mx_services'] = new THREE.MeshBasicMaterial( { map: basicTexture('sph.mx_services'), name:'sph.mx_services' } );
            mats['sph.mx_food'] = new THREE.MeshBasicMaterial( { map: basicTexture('sph.mx_food'), name:'sph.mx_food' } );            
	    mats['sph.mx_office'] = new THREE.MeshBasicMaterial( { map: basicTexture('sph.mx_office'), name:'sph.mx_office' } );    
            mats['sph.mx_car'] = new THREE.MeshBasicMaterial( { map: basicTexture('sph.mx_car'), name:'sph.mx_car' } );            
	    mats['sph.mx_auto'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_auto'), name:'sph.mx_auto' } );            
	    mats['sph.mx_travel'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_travel'), name:'sph.mx_travel' } );            
            mats['sph.mx_sport'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_sport'), name:'sph.mx_sport' } );            
	    mats['sph.mx_beauty'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_beauty'), name:'sph.mx_beauty' } );            
	    mats['sph.mx_health'] = new THREE.MeshPhongMaterial( { map: basicTexture('sph.mx_health'), name:'sph.mx_health' } );            
            mats['box'] = new THREE.MeshBasicMaterial( { map: basicTexture(1), name:'box' } );
            mats['filter'] = new THR
EE.MeshLambertMaterial( { color: 0x3D4143, transparent:true, opacity:0.6 } );            
            mats['ground'] = new THREE.MeshBasicMaterial( { color:debugColor, wireframe:true, transparent:true, opacity:0, fog: false, depthTest: false, depthWrite: false});
        }

        container = document.getElementById("lab");
        container.appendChild( renderer.domElement );

        initEvents();
        initOimoPhysics();
    }

    function loop() {
        requestAnimationFrame( loop );
        renderer.render( scene, camera );
    }

function addStaticBox(size, position, rotation, spec) {
        var mesh;
        if(spec) mesh = new THREE.Mesh( geos.box, mats.filter );
        else mesh = new THREE.Mesh( geos.box, mats.box );
        mesh.scale.set( size[0], size[1], size[2] );
        mesh.position.set( position[0], position[1], position[2] );
        mesh.rotation.set( rotation[0]*ToRad, rotation[1]*ToRad, rotation[2]*ToRad );
        scene.add( mesh );
        grounds.push(mesh);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
    }

    function addGround(size, position, rotation) {
        var mesh = new THREE.Mesh(geos.box, mats.ground);
        mesh.scale.set( size[0], size[1], size[2] );
        mesh.position.set( position[0], position[1], position[2] );
        mesh.rotation.set( rotation[0]*ToRad, rotation[1]*ToRad, rotation[2]*ToRad );

        /*
        var helper = new THREE.BoxHelper(mesh);
        helper.material.color.setHex( debugColor );
        helper.material.opacity = debugAlpha;
        helper.material.transparent = true;
        mesh.add(helper);
        */
	helper2 = new THREE.GridHelper( 0.5, 0.0625 );
	helper2.setColors( debugColor2, debugColor );
	helper2.material.opacity = debugAlpha;
        helper2.material.transparent = true;
	helper2.position.y = 0.5;
	mesh.add(helper2);
        
        scene.add(mesh);
        grounds.push(mesh);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
    }

    function clearMeshes(){
        var i=meshs.length;
        while (i--) spheres.remove(meshs[ i ]);
        i = grounds.length;
        while (i--) scene.remove(grounds[ i ]);                
        grounds = [];
        meshs = [];
    }

    //----------------------------------
    //  OIMO PHYSICS
    //----------------------------------

    function initOimoPhysics(){

        // world setting:( TimeStep, BroadPhaseType, Iterations )
        // BroadPhaseType can be 
        // 1 : BruteForce
        // 2 : Sweep and prune , the default 
        // 3 : dynamic bounding volume tree

        world = new OIMO.World(1/60, 2, 8);
        populateWorld(0);
    }

    function populateWorld(month) {
    
        // Reset old
        turnOffInspector();
        clearInterval(updateOimoPhysics, 1000/60);
        currentDate = 0;
        document.getElementById("dayInfo").innerHTML = '';        
        clearMeshes();
        world.clear();

        // add ground
        var ground = new OIMO.Body({size:[1000, 100, 1000], pos:[0,-50,0], world:world, config: config});
        addGround([1000, 1, 1000], [0,0,0], [0,0,0]);

        // add walls
        var wall1 = new OIMO.Body({size:[1100, 2000, 50], pos:[0,1000,525], world:world, config: config});
        var wall2 = new OIMO.Body({size:[1100, 2000, 50], pos:[0,1000,-525], world:world, config: config});               
        var wall3 = new OIMO.Body({size:[50, 2000, 1000], pos:[525,1000,0], world:world, config: config});
        var wall4 = new OIMO.Body({size:[50, 2000, 1000], pos:[-525,1000,0], world:world, config: config});
        
        // dataset by month
        var dataset = getCurrentDataset();
        var categories = Object.keys(dataset);
        var fromDay = 0;
        var toDay = 0;
        for (var i = 0; i <= month; i++) {
            toDay += daysOfMonth[i];
            if (i > 0) {
                fromDay += daysOfMonth[i - 1];
            }
        }

        // add objects
        var i = 0;
        var x, y, z, w, h, d,p, date;
        for (var day = fromDay; day < toDay; day++)
        {
            date = dataset[categories[0]].stats[day].date;
            y = (day - fromDay + 1) * yGapBetweenDays;

            for (var categoryIdx = 0; categoryIdx < categories.length; categoryIdx++) {
                var category = categories[categoryIdx];
                var cubesByCategoryAndDay = dataset[category].stats[day].cube;
                
                for (var cubeIdx = 0; cubeIdx < cubesByCategoryAndDay.length; cubeIdx++) {
                    var cube = cubesByCategoryAndDay[cubeIdx];

                    var numBodiesPerCube =
                        Math.floor(cube.num_payments / paymentsPerSphere) +
                        ((cube.num_payments % paymentsPerSphere > 0) ? 1 : 0);
                    
                    for (var j = 0; j < numBodiesPerCube; j++) {
                        x = -500 + Math.random()*1000;
                        z = -500 + Math.random()*1000;
			p = Math.floor(cube.avg / paymentBucket);
                        if (p < 5) {
                             w = (p + 1) * radioPerPaymentBucket;
                         } else {
			     w= p* radioPerPaymentBucket / 5;
                         }
                        
                        var numPayments = (((j + 1) * paymentsPerSphere) > cube.num_payments) ?
                            cube.num_payments % paymentsPerSphere :
                            paymentsPerSphere;
                        
                        // Create sphere body and mesh
                        var sphereMetadata = {
                            date: date,
                            category: category,
                            payments: numPayments,
                            avg: cube.avg,
                            gender: cube.hash.substring(0,1),
                            age: cube.hash.substring(2),
                            landed: false
                        };
                        config[3] = sphereMetadata.gender == 'M' ? group2 : group3;                        
                        bodys[i] = new OIMO.Body({type:'sphere', size:[w*0.5], pos:[x,y,z], move:true, sleeping: false, world:world, metadata: sphereMetadata, config: config});
                        meshs[i] = new THREE.Mesh( geos.sphere, mats['sph.' + category]);
                        meshs[i].name = i;
                        meshs[i].userData = sphereMetadata;
                        meshs[i].scale.set( w*0.5, w*0.5, w*0.5 );           
                        meshs[i].castShadow = true;
                        meshs[i].receiveShadow = true;
                        //scene.add(meshs[i++]);
                        spheres.add(meshs[i++]);
                    } // bodies                    
                } // cubes                
            } // categories
        } // days

        physicsUpdateInterval = setInterval(updateOimoPhysics, 1000/60);        
    }

    function updateOimoPhysics() {
        world.step();

        var x, y, z;
        var i = spheres.children.length;
        var mesh;
        var body; 

        while (i--) {
            body = bodys[i].body;
            mesh = meshs[i];

            mesh.position.copy(body.getPosition());
            mesh.quaternion.copy(body.getQuaternion());

            // landing objects
            if ((mesh.position.y < 100) && (!bodys[i].metadata.landed)) {
                bodys[i].metadata.landed = true;
                if (bodys[i].metadata.date > currentDate) {
                    currentDate = bodys[i].metadata.date;
                    document.getElementById("dayInfo").innerHTML = bodys[i].metadata.date;
                }
            }
            
            // reset position
            if (mesh.position.y < -100){
                x = -100 + Math.random()*200;
                z = -100 + Math.random()*200;
                y = 100 + Math.random()*1000;
                body.resetPosition(x,y,z);
            }
        }
    }

    function gravity(g){
        nG = -10;
        world.gravity = new OIMO.Vec3(0, nG, 0);
    }

    //----------------------------------
    //  TEXTURES
    //----------------------------------

    function gradTexture(color) {
        var c = document.createElement("canvas");
        var ct = c.getContext("2d");
        c.width = 16; c.height = 128;
        var gradient = ct.createLinearGradient(0,0,0,128);
        var i = color[0].length;
        while(i--){ gradient.addColorStop(color[0][i],color[1][i]); }
        ct.fillStyle = gradient;
        ct.fillRect(0,0,16,128);
        var texture = new THREE.Texture(c);
        texture.needsUpdate = true;
        return texture;
    }

    function basicTexture(texture){
        var canvas = document.createElement( 'canvas' );
        canvas.width = canvas.height = 64;
        var ctx = canvas.getContext( '2d' );
        var color = textureColors[texture];

        ctx.fillStyle = color;
        ctx.fillRect(0, 0, 64, 64);
        ctx.fillStyle = "rgba(0,0,0,0.2);";//colors[1];
        ctx.fillRect(0, 0, 32, 32);
        ctx.fillRect(32, 32, 32, 32);
        var tx = new THREE.Texture(canvas);
        tx.needsUpdate = true;
        return tx;
    }

    // Raycast Test
    var rayTest = function () {
        if (inspectorActivated && mouse.down) {
            var vector = new THREE.Vector3( mouse.mx, mouse.my, 1 );
            projector.unprojectVector( vector, camera );
            raycaster.set( camera.position, vector.sub(camera.position).normalize());
            var intersects = raycaster.intersectObjects(spheres.children, true);
            if (intersects.length > 0) {
                if (selectedMesh) {
                    selectedMesh.material = previousSelectedMeshMaterial;
                }
                selectedMesh = intersects[0].object;
                var selectedBody = bodys[selectedMesh.name].body;
                var metadata = selectedMesh.userData;
                document.getElementById("sphereInfo").innerHTML =
                    "Date: " + metadata.date + "<br/>" +
                    "Category: " + metadata.category + "<br/>" +
                    "Payments: " + metadata.payments + "<br/>" +
                    "Avg payment: " + metadata.avg + "<br/>" +
                    "Gender: " + genderAsString(metadata.gender) + "<br/>" +
                    "Age: " + ageAsString(metadata.age);
                //selectedBody.resetPosition(selectedBody.position.x, 200, selectedBody.position.z);
                previousSelectedMeshMaterial = selectedMesh.material;
                selectedMesh.material = selectedMesh.material.clone();
                selectedMesh.material.color.setRGB(.5,0,0);
            }        
        }
    }

    // UI Controls

    function getCurrentDataset() {
        return monterrey_tech_dataset;
    }

    function toggleInspector() {
        inspectorActivated = !inspectorActivated;
        if (inspectorActivated) {
            document.getElementById("inspectorBtn").className = "activated";
        } else {
            document.getElementById("sphereInfo").innerHTML = "";            
            document.getElementById("inspectorBtn").className = "";
            if (selectedMesh) {
                selectedMesh.material = previousSelectedMeshMaterial;
            }
        }
    }

    function turnOffInspector() {
        if (inspectorActivated) {
            toggleInspector();
        }
    }

    function activateFilter() {
        config[3] = group1;
        config[4] = all & ~group2; // all except group2
        var filter = new OIMO.Body({size:[5, 100, 390], pos:[0,40,0], rot:[0,0,0], world:world, config:config});
        addStaticBox([10, 400, 1000], [0,200,0], [0,0,0], true);            
    }

    function genderAsString(gender) {
        var genders = {
            'M': 'male',
            'F': 'female',
            'E': 'enterprise',
            'U': 'unknown'
        };
        return genders[gender];
    }

    function ageAsString(age) {
        var ages = {
            '0': '<= 18',
            '1': '19 - 25',
            '2': '26 - 35',
            '3': '36 - 45',
            '4': '46 - 55',
            '5': '56 - 65',
            '6': '> 66',
            'U': 'unknown'
        };
        return ages[age];    
    }

</script>
</body>
</html>
